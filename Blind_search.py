# -*- coding: utf-8 -*-
"""Copia de Blind search (BFS & DFS).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XbIsFdGZCQFOpUSUTzpTAriEEaumsWTG

# Implementation of BFS and DFS

Let us assume that the node will contain the following information:
- The label (the "name" of the node)
- The parent (the label of the node that created this node)
- The cost of reaching this node

Although there are other more efficient coding practices for this (such as object oriented programming), we will prefer simplicity over efficiency. For this reason, we will represent the nodes using tuples: <code>(label, parent, cost)</code>.
"""

# =======================
# Adds a node to the frontier if, and only if it is not contained in the frontier
# or the list of explored nodes.
# =======================
def add(successor, frontier, explored, type):
  new  = True
  # Revises if the node is already contained in the frontier
  for node in frontier:
    if node[0] == successor[0]:
      new = False
  # Revises if the node is already contained in the list of explored nodes
  if (new):
    for node in explored:
      if node[0] == successor[0]:
        new = False
  # If the node is not contained in the frontier or the list of explored nodes, it is added to the frontier
  if (new):
    if (type == "bfs"):
      frontier.append(successor)
    else:
      frontier.insert(0, successor)    
  return frontier

# =======================
# Formats the solution (not really needed, but helps the solution to be undestood).
# =======================
def format(parent, explored, solution):  
  if (parent != None):    
    for node in explored:      
      if node[0] == parent:
        #sol = f"{parent}" + " -> " + f"{solution}"
        sol = [parent] + solution
        return format(node[1], explored, sol)
  return solution

# =======================
# Implements BFS and DFS
# =======================
def search(frontier, explored, node, goal, type):
  # Create list of possible movements
  functions =   [move1M, move2M, move1C, move2C, moveMC]
  # Sanity check in case the initial state is a goal one
  if (frontier[0] == goal):
      print(format(node[1], explored, [node[0]]))
      return format(node[1], explored, [node[0]])
  # As long as there are nodes in the frontier
  cont = 0
  while (frontier):
    cont = cont +1
    # Extracts the first node from the frontier
    node = frontier.pop(0)    
    # Inserts the node into the list of explored nodes
    explored.append(node)    
    # Creates the successors of the node and, if the successors are not contained in the frontier or the list of explored nodes, it is inserted into the frontier (FIFO)
    for f in functions:
      successor = f(node[0])
      if successor != None:
        #Check if goal
        # (0,0,0)
        if (goal == successor):                    
          print(format(node[0], explored, [successor]))
          return format(node[0], explored, [successor])
        #create new node and add to frontier
        newNode = (successor, node[0],  node[2]+1)
        frontier = add(newNode, frontier, explored, type)

  # If the frontier is empty, no solution was found
  print("No solution found.")
  return False

def checkEaten(state):
  # Returns true if eaten.
  if ((state[0] < state[1] and (state[0]) != 0) or (((3 - state[0]) < (3 - state[1])) and (3 - state[0]) != 0)):
    return True;
  return False;

def move1M(state):
  # If there's 1 missionary and the boat is on this side
  if (state[0] >= 1 and state[2] == 1):
    successor = (state[0] -1, state[1], 0)
    if checkEaten(successor): return None
    return successor
  # There's one missionary on the other side, and the boat is on that side as well
  if (state[0] <= 2 and state[2] == 0):
    successor = (state[0] + 1, state[1], 1)
    if checkEaten(successor): return None
    return successor

def move2M(state):
  # If there's 2 missionaries and the boat is on this side
  if (state[0] >= 2 and state[2] == 1):
    successor = (state[0] -2, state[1], 0)
    if checkEaten(successor): return None
    return successor
  # There's two missionaries on the other side, and the boat is on that side as well
  if (state[0] <= 1 and state[2] == 0):
    successor = (state[0] + 2, state[1], 1)
    if checkEaten(successor): return None
    return successor

def move1C(state):
  # If there's 1 cannibal and the boat is on this side
  if (state[1] >= 1 and state[2] == 1):
    successor = (state[0], state[1]-1, 0)
    if checkEaten(successor): return None
    return successor
  # There's one cannibal on the other side, and the boat is on that side as well
  if (state[1] <= 2 and state[2] == 0):
    successor = (state[0], state[1]+1, 1)
    if checkEaten(successor): return None
    return successor

def move2C(state):
  # If there's 2 cannibals and the boat is on this side
  if (state[1] >= 2 and state[2] == 1):
    successor = (state[0], state[1]-2, 0)
    if checkEaten(successor): return None
    return successor
  # There's two cannibals on the other side, and the boat is on that side as well
  if (state[1] <= 1 and state[2] == 0):
    successor = (state[0], state[1]+2, 1)
    if checkEaten(successor): return None
    return successor

def moveMC(state):
  # If there's 1 cannibal and 1 missionary on this side
  if (state[0] >= 1 and state[1] >= 1 and state[2] == 1):
    successor = (state[0]-1, state[1]-1, 0)
    if checkEaten(successor): return None
    return successor
  # If there's 1 cannibal and 1 missionary on the other side
  if (state[0] <= 2 and state[1] <= 2 and state[2] == 0):
    successor = (state[0]+1, state[1]+1, 1)
    if checkEaten(successor): return None
    return successor

def solver(mode):
  state = (3,3,1)
  start = (state, None, 0)
  
  frontier = [start]
  explored = []
  solution = search(frontier, explored, start, (0,0,0), mode)
  return solution